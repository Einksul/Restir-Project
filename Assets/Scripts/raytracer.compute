// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Raycast

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;
RWTexture2D<float4> Result;

static const float PI = 3.14159265f;
int StartSeed = 1293576;

struct Ray{
    float3 luminance;
    float3 energy;
    float3 origin;
    float3 dir;
};

struct RayHit
{
    float3 pos;
    float distance;
    float3 normal;
    float3 color;
    float3 EmissionColor;
    float lightIntensity;
};

struct DirectionalLight
{
    
};

struct Sphere
{
    float3 pos;
    float radius;
    float3 color;
    float3 EmissionColor;
    float lightIntensity;
};

StructuredBuffer<Sphere> spheres;
int sphereCount;

struct Mesh
{
    float4x4 transform;
    int indexOffset;
    int indexCount;
};
StructuredBuffer<Mesh> meshes;
Buffer<float3> vertices;
Buffer<int> indices;
int meshCount;


void IntersectSphere(Ray rei, Sphere sphere, inout RayHit toBeat)
{
    // Calculate distance along the ray where the sphere is intersected
    float3 d = rei.origin - sphere.pos;
    float p1 = -dot(rei.dir, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
    if (p2sqr < 0)
        return;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < toBeat.distance)
    {
        toBeat.distance = t;
        toBeat.pos = rei.origin + (t-0.001) * rei.dir;
        toBeat.normal = normalize(toBeat.pos - sphere.pos);
        toBeat.color = sphere.color;
        toBeat.EmissionColor = sphere.EmissionColor;
        toBeat.lightIntensity = sphere.lightIntensity;
    }
    
}

Ray CreateRay(float3 origin, float3 direction){
    Ray adachi;
    adachi.origin = origin;
    adachi.dir = direction;
    adachi.energy = float3(1,1,1);
    adachi.luminance = float3(0,0,0);
    
    return adachi;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

void specularMaterial(inout Ray payload, RayHit hitinfo)
{
    payload.energy *= 0.8;
    payload.dir = reflect(payload.dir, hitinfo.normal);
    payload.origin = hitinfo.pos;
}

uint Hash(uint s)
{
    s = s ^ 61u ^ (s >> 16u);
    s *= 9u;
    s = s ^ (s >> 4u);
    s *= 0x27d4eb2du;
    s = s ^ (s >> 15u);
    return s;
}
float Randn(inout uint seed)
{
    seed += 1u;
    return float(Hash(seed)) / float(0xFFFFFFFFu); 
}

void Basis(float3 normal, out float3 T, out float3 B)
{
    if (abs(normal.z) < 0.999f) 
    {
        T = normalize(cross(float3(0, 0, 1), normal));
    }
    else
    {
        T = normalize(cross(float3(1, 0, 0), normal));
    }
    B = cross(normal, T);
}

float3 CosineSample(inout uint state, float3 N)
{
   
    float R1 = Randn(state); 
    float R2 = Randn(state); 

    
    float phi = 2.0 * PI * R1;
    float cosTheta = sqrt(R2);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    
    float3 localDir = float3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta
    );

    
    float3 T, B;
    Basis(N, T, B);
    return T * localDir.x + B * localDir.y + N * localDir.z;
}
void diffuse(inout Ray payload, RayHit hitinfo, inout uint state)
{

    float3 emittedLight = hitinfo.EmissionColor * hitinfo.lightIntensity;
    payload.luminance += payload.energy * emittedLight;
    
    payload.energy *= hitinfo.color;
    
    payload.dir = CosineSample(state, hitinfo.normal);
    
    payload.origin = hitinfo.pos;
}

void missShader(inout Ray payload)
{
    float phi = acos(payload.dir.y) / -PI;
    float theta = atan2(payload.dir.x, -payload.dir.z) / -(2 * PI);
    float3 skyboxSample = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(theta, phi), 0).xyz;
    payload.luminance += skyboxSample * payload.energy;
}

RayHit freshHit()
{
    RayHit newHit;
    newHit.pos = float3(0, 0, 0);
    newHit.normal = float3(0, 0, 0);
    newHit.distance = 1.#INF;
    return newHit;
}

[numthreads(8,8,1)] 
void Raycast (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    // convert id to uv
    // createcameraray(uv.x uv.y)
    // sample skybox accordingly
    int width, height;
    Result.GetDimensions(width, height);

    // rescale to [-1, 1] 
    float2 uv = float2((id.xy + float2(0.5, 0.5)) / float2(width, height) * 2.0f - 1.0f);
    Ray c_ray = CreateCameraRay(uv); 
    uint rngState = (id.x * 1973u) ^ (id.y * 9277u) ^ StartSeed;
    
    // megakernels considered harmful
    for (int i = 0; i < 8; i++)
    {
        RayHit current = freshHit();
        for (int j = 0; j < sphereCount; j++)
        {
            IntersectSphere(c_ray, spheres[j], current);
        }
        
        if (current.distance >= 2000)
        {
            missShader(c_ray);
            break;
        } 
        
        if (!any(c_ray.energy))
        {
            break;
        }
        // specularMaterial(c_ray, current);
        diffuse(c_ray, current, rngState);
        
    }
    
    Result[id.xy] = float4(c_ray.luminance, 1);

}
