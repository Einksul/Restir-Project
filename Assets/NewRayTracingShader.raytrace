// Uncomment this pragma for debugging the HLSL code in PIX. GPU performance will be impacted.
//#pragma enable_ray_tracing_shader_debug_symbols

#ifndef RT_PATHTRACING
#define RT_PATHTRACING

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityGBuffer.hlsl"

#include "includes/Restir.hlsl"
#include "includes/Utils.hlsl"
#include "includes/Global.hlsl"
#include "includes/BRDF.hlsl"

uint g_ConvergenceStep;
uint g_FrameIndex;
float g_Zoom;
float g_AspectRatio;
uint g_BounceCountOpaque;
uint g_BounceCountTransparent;
int g_ReSTIR;
int g_ClearBuffer;

RaytracingAccelerationStructure g_AccelStruct : register(t0, space1);

RWTexture2D<float4> g_Output : register(u0);

TextureCube<float4> g_EnvTex;
SamplerState sampler_g_EnvTex;

Texture2D<float4> _DepthTex;

Texture2D<float4> _AlbedoBufferTex; // GBuffer_0

Texture2D<float4> _SpecularBufferTex; // GBuffer_1

Texture2D<float4> _NormalBufferTex; // GBuffer_2

RWStructuredBuffer<Reservoir> _RestirBuffer;

#pragma max_recursion_depth 10

float4 DecodeNormalBuffer(uint2 texcoord)
{    
    float4 normalBuffer = _NormalBufferTex[texcoord];
    float3 packNormalWS = normalBuffer.rgb;
    float3 unpackNormalWS = UnpackNormal(packNormalWS);

    // rgb = normalWS, a = smoothness
    return float4(unpackNormalWS, clamp(normalBuffer.a, 1e-4, 1 - 1e-4));
}

float3 GetRayDirection(float2 frameCoord, uint2 launchDim, bool jit, inout uint seed)
{
    // Plus a jitter for anti-aliasing. Only works for frames-accumulating.
    float2 ndcCoords = (frameCoord + 
        (jit ? float2(RandomFloat01(seed), RandomFloat01(seed)) : float2(0, 0))
        - float2(0.5, 0.5))
        / float2(launchDim.x - 1, launchDim.y - 1);
    
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    // Get a ray in view space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    return mul((float3x3)unity_CameraToWorld, viewDirection);
}

[shader("raygeneration")]
void PathTracingRayGenShader()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;
    
    // Initial random number generator seed for this pixel. The rngState will change every time we draw a random number.
    uint rngState = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(g_ConvergenceStep + g_FrameIndex) * uint(26699)) | uint(1);
    
    // Shoot rays through the center of a pixel.
    float2 frameCoord = launchIndex + float2(0.5, 0.5);

    float3 rayDirection = GetRayDirection(frameCoord, launchDim, true, rngState);    

    RayDesc ray;
    ray.Origin      = _WorldSpaceCameraPos;
    ray.Direction   = rayDirection;
    ray.TMin        = K_T_MIN;
    ray.TMax        = K_T_MAX;

    float3 throughput = float3(1, 1, 1);

    PathPayload payload;
    payload.radiance                = float3(1, 1, 1);
    payload.emission                = float3(0, 0, 0);
    payload.rngState                = rngState;
    payload.bounceIndexOpaque       = 0;
    payload.bounceIndexTransparent  = 0;
    payload.bounceRayDirection      = float3(0, 0, 0);
    payload.pushOff                 = float3(0, 0, 0);
    payload.hitPointNormal          = float3(0, 0, 0);
    payload.T                       = 0;
    
    // Safe net for when shaders have compilation errors and don't increase the bounce index, resulting in an infinite loop.
    uint safeNet = 0;
    bool hit = false;

    do
    {
        TraceRay(g_AccelStruct, 0, 0xFF, 0, 1, K_MISS_SHADER_PT_INDEX, ray, payload);

        if(Luminance(payload.emission) > 0)
        {// hit light, end the path
            throughput *= payload.emission;
            hit = true;
            break;
        }

        // continue the path
        throughput *= payload.radiance;

#define ENABLE_RUSSIAN_ROULETTE 1
#if ENABLE_RUSSIAN_ROULETTE
        float pathStopProbability = 1;
        pathStopProbability = max(throughput.r, max(throughput.g, throughput.b));
        // Dark colors have higher chance to terminate the path early.
        if (pathStopProbability < RandomFloat01(payload.rngState))
        {
            throughput = float3(0, 0, 0);
            break;
        }
        throughput *= rcp(pathStopProbability);
#endif

        ray.Origin      = ray.Origin + ray.Direction * payload.T + payload.pushOff;
        ray.Direction   = payload.bounceRayDirection;
    }
    while ((payload.bounceIndexOpaque <= g_BounceCountOpaque) && (payload.bounceIndexTransparent <= g_BounceCountTransparent) && (++safeNet < 1000));

    if(!hit) throughput = float3(0, 0, 0);

    // Accumulation?
    float3 prevRadiance = g_Output[launchIndex].xyz;
    float3 result = (g_ConvergenceStep == 0) ? throughput : lerp(prevRadiance, throughput, rcp(float(g_ConvergenceStep + 1)));
    g_Output[launchIndex] = float4(result, 1);
}

[shader("miss")]
void MissShader0_Primary(inout PathPayload payload : SV_RayPayload)
{
    payload.emission                = g_EnvTex.SampleLevel(sampler_g_EnvTex, WorldRayDirection(), 0).xyz;
    payload.bounceIndexOpaque       = K_MAX_BOUNCES;
}

#endif